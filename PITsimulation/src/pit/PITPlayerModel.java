// package
package pit;

// imports
import java.io.Serializable;
import java.util.*;
import javax.jms.*;
import javax.jms.Queue;
import javax.naming.*;

/* This is the ONLY file that you are to edit.  It is the model of play for
 * every PITplayer. Each PITplayer instantiates this model and uses it to
 * process the messages it receives.*/
class PITPlayerModel {

    // Each PITplayer has a unique myPlayerNumber.  It is set in the PITPlayer constructor.
    private final int myPlayerNumber;
    // Cards is this player's set of cards.
    private final ArrayList cards = new ArrayList();
    // numTrades counts trades.
    private int numTrades = 0;
    // maxTrades is the maximum number of trades, after which trading is stopped.
    private final int maxTrades = 20000;
    // numPlayers are the number of Players trading.  This comes with a NewHand from the PITsnapshot servlet
    private int numPlayers = 0;
    // halting indicates that the system is being reset, so ignore trades until a new had received
    private boolean halting = false;
    // boolean to check the first Marker
    private boolean firstMarker;
    // Hashmap to store the state of the players
    private HashMap<String, Integer> state = null;
    // create a new hashSet that stores the number of channels
    private HashSet channel = new HashSet();

    /* The snapshot servlet (PITsnapshot) is expecting to be passed an ObjectMessage
     * where the  object is a HashMap. Therefore this definition of HashMap is
     * provided although it  is not currently used (it is for you to use).
     * PITsnapshot is expecting a  set of attribute/value pairs. These include the player
     * number, as in state.put("Player",myPlayerNumber),  and each commodity string
     * and the number of that commodity  in the snapshot.
     * Also included below is a utility method  that will convert a HashMap into a string
     * which is useful for printing diagnostic messages to  the console.
     */

    // PITPlayerModel constructor saves what number player this object represents.
    PITPlayerModel(int myNumber) {
        myPlayerNumber = myNumber;
    }

    void onMessage(Message message) {
        try {
            if (message instanceof ObjectMessage) {
                Object o = ((ObjectMessage) message).getObject();

                /* There are 6 types of messages:  Reset, NewHand, TenderOffer,
                 * AcceptOffer, RejectOffer, and Marker
                 */

                // Reset the Player.  This message is generated by the PITsnapshot servlet
                if (o instanceof Reset) {
                    doReset((Reset) o);

                    // NewHand received from PITsnapshot
                } else if (o instanceof NewHand) {
                    // Add the new hand into cards
                    doNewHand((NewHand) o);

                    // Receive an offer from another Player
                } else if (o instanceof TenderOffer) {
                    doReceiveTenderOffer((TenderOffer) o);

                    // Another Player accepted our offer
                } else if (o instanceof AcceptOffer) {
                    doReceiveAcceptOffer((AcceptOffer) o);

                    // Another Player rejected our offer
                } else if (o instanceof RejectOffer) {
                    doReceiveRejectOffer((RejectOffer) o);
                    // Check if the message is an instance of Marker.
                } else if (o instanceof Marker) {
                    // Call the markerWork method with the message as the argument
                    markerWork((Marker) o);
                }
                else {
                    System.out.println("PITplayer" + myPlayerNumber + " received unknown Message type");
                    // just ignore it
                }
            }
        } catch (Exception e) {
            System.out.println("Exception thrown in PITplayer" + myPlayerNumber + ": " + e);
        }
    }

    /*This is the method created to add player number and the commodity card to the state hashmap
    after checking if the hashmap contains the commodity card, increment its number by 1, else
    add a new key with 1 as its quantity. this method will be called in markerWork(), doReceiveAcceptOffer(),
    doReceiveRejectOffer(), and doReceiveTenderOffer(). */
    private void SnapshotAddition(String pitPlayerCard) {
        // check if the player has the commodity
        if (state.containsKey(pitPlayerCard)) {
            // increment by 1
            state.put(pitPlayerCard, state.get(pitPlayerCard) + 1);
        } else {
            // else add the commodity in the state hashmap with quantity as 1
            state.put(pitPlayerCard, 1);
        }
    }

    /*This method is called if the Marker is received by any of the players. It checks if the Marker
    boolean flag is false, changes the flag to true and then stores the initial state of the player
    that receives the marker. The method checks if the player has already received a marker and does
    nothing if the player has. The method at the end clears the channel if the marker flag is true*/
    private void markerWork(Marker marker) throws Exception {
        // if the source is none, add the source of marker to the channel
        if (marker.source != -1) {
            channel.add(marker.source);
        }
        // check the Marker boolean flag to be false
        if (!firstMarker) {
            firstMarker=true;
            // initialize the state hashmap
            state = new HashMap();
            // put in the hashmap the number of the player
            state.put("Player", myPlayerNumber);
            // for all the cards that the player holds call the SnapshotAddition method
            for (Object c : cards) {
                // add the player number and card one by one
                SnapshotAddition((String) c);
            }
            // print the state using the over-ridden toString() on to the console
            System.out.println(toString(state));
            // check for all the players other than the player that has received the marker
            for (int i = 0; i < numPlayers; i++) {
                // if player is other than the player who has received the marker
                if (i != myPlayerNumber) {
                     /*send the marker to the players queue. The new marker is sent from the player who
                     received the marker in the first place*/
                    sendToQueue("openejb:Resource/PITplayer" + i, new Marker(myPlayerNumber));
                }
            }
        // if the Marker boolean flag is false
        } else {
            // check if all the players have been added to the channel
            if (channel.size() == numPlayers -1) {
                // set the marker boolean flag to false again for another iteration
                firstMarker=false;
                // clear the channel for other iterations
                channel.clear();
                // send the state to the PITSnapshot queue
                sendToQueue("openejb:Resource/PITsnapshot", state);
            }
        }
    }

    /*This method resets the clears the cards array, sets number of trades and players to 0.
    * It would reset the simulation*/
    private void doReset(Reset reset) throws Exception {
        // Resetting is done by two messages, first to halt, then to clear
        if (reset.action == Reset.HALT) {
            System.out.println("PITplayer" + myPlayerNumber + " received Reset HALT");
            halting = true;
            // Reply to the PITsnapshot servlet acknowledging the Reset HALT
            sendToQueue("openejb:Resource/PITmonitor", reset);
        } else { // action == Reset.CLEAR
            System.out.println("PITplayer" + myPlayerNumber + " received Reset RESET");
            // Drop all cards in hand
            cards.clear();
            numTrades = 0;
            numPlayers = 0;
            halting = false;
            // Reply to the PITsnapshot servlet acknowledging the Reset
            sendToQueue("openejb:Resource/PITmonitor", reset);
        }
    }

    /*This method starts a newHand. It sends every players a combination of 12 commodity cards
    * by calling the doTenderOffer() method*/
    private void doNewHand(NewHand hand) throws Exception {
        // Add a new hand of cards.
        // It is actually possible that an offer from another Player has been
        // accepted already, beating the NewHand
        cards.addAll((hand).newHand);
        numPlayers = (hand).numPlayers;
        System.out.println("PITplayer" + myPlayerNumber + " new hand: " + toString(cards));
        // Offer a card to another Player
        doTenderOffer();
    }

    /*This method is used to receive the commodity card that is traded by one of the randomly chosen players.
    * If the receiving conditions are satisfied the player accepts the card. Else it will reject it and send it back to
    * the queue of the player who initiated the trade.
    * In task 1, the accepting of card is done using a random number generation.
    * In task 2, the card is accepted by the player only if it matches the commodity which the player has the most*/
    private void doReceiveTenderOffer(TenderOffer trade) throws Exception {
        if (halting) {
            // if halting, discard trade
            return;
        }
        System.out.println("PITplayer" + myPlayerNumber + " received offer of: " + trade.tradeCard + " from player: " + trade.sourcePlayer);

        // Task 2
        // Create a new Hashmap to find which commodity is in abundance with each player
        Map<String, Integer> maxCommodityMap = new HashMap<String, Integer>();

        /*took a little help from stack-over-flow for this block*/
        /*for all the commodity cards in the cards that the player holds, use a hashmap
        to find the number of quantity of each commodity.
        iterate for all the cards in the cards on hand*/
        for (Object card : cards) {
            // check if the card is null
            if (maxCommodityMap.get(card) == null) {
                // put the card in the hashmap with value as 1
                maxCommodityMap.put((String) card, 1);
            // if the card is present in the map, increment its value by 1
            } else {
                maxCommodityMap.put((String) card, maxCommodityMap.get(card) + 1);
            }
        }

        // new variable for the maximum quantity in the hashmap
        int maxCard = 0;
        // new variable for the card with the maximum quantity
        String monopolyCard = "";

        // check for all the key value pair in the hashmap
        for (Map.Entry<String, Integer> cardCountPair : maxCommodityMap.entrySet()) {
            // store the key and value pair in new variables
            String commodity = cardCountPair.getKey();
            int commodityCount = cardCountPair.getValue();
            // if the quantity of the commodity is greater than the maxCard quantity
            if (commodityCount>maxCard){
                // update the card with the maximum quantity
                monopolyCard = commodity;
                // update the maximum quantity
                maxCard = commodityCount;
            }
        }

        /*When receiving an offer, decide whether to Accept or Reject it.
        Check if the commodity card is the same as the card that the player has in abundance*/
        if (trade.tradeCard.equals(monopolyCard)) {
            // Add the Offer to my hand of cards
            cards.add(trade.tradeCard);
            // Pay with one of my cards
            doReplyAccept(trade.sourcePlayer);
        }

        // Uncomment the below block for Task1

        /* Accept the trade 80% of the time*/
        /*if (Math.random() < 0.8) {
            // Add the Offer to my hand of cards
            cards.add(trade.tradeCard);

            // Pay with one of my cards
            doReplyAccept(trade.sourcePlayer);
        }*/

        else {
            // Otherwise reject the offer and send back the card
            doReplyReject(trade);
        }

        /*check if the marker boolean flag is true and the channel does not contain the player
        who initiated the trade. If the condition is satisfied add the player who initiated
        the trade and the card being traded to the snapshot*/
        if(firstMarker & !channel.contains(trade.sourcePlayer)) {
            SnapshotAddition(trade.tradeCard);
        }
    }

    /*This method does a reply to the player who initiates a trade with a player. The reply is also a commodity card
    * that is sent to the queue of the player who initiated the trade in the first place.*/
    private void doReplyAccept(int sendTo) throws Exception {
        // if hit maxTrades limit, then stop sending trades
        if (maxTrades(maxTrades)) {
            return;
        }

        // In payment for the card I just accepted, send back one of my cards.
        AcceptOffer newTrade = new AcceptOffer();
        newTrade.tradeCard = (String) cards.remove(0);
        newTrade.sourcePlayer = myPlayerNumber;

        //Send the card to the other player
        System.out.println("PITplayer" + myPlayerNumber + " accepting offer and paying with: " + newTrade.tradeCard + " to player: " + sendTo);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));
        String sendToJNDI = "openejb:Resource/PITplayer" + sendTo;
        sendToQueue(sendToJNDI, newTrade);
    }

    // Reply rejecting an offer that was received.  Send back their card.
    private void doReplyReject(TenderOffer trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }
        System.out.println("PITplayer" + myPlayerNumber + " rejecting offer of: " + trade.tradeCard + " from player: " + trade.sourcePlayer);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));
        // if hit maxTrades limit, then stop sending trades
        if (maxTrades(maxTrades)) {
            return;
        }
        // Send back their card that I am rejecting
        RejectOffer newTrade = new RejectOffer();
        newTrade.tradeCard = trade.tradeCard;
        newTrade.sourcePlayer = myPlayerNumber;

        //Send the card to the other player
        String sendToJNDI = "openejb:Resource/PITplayer" + trade.sourcePlayer;
        sendToQueue(sendToJNDI, newTrade);
    }

    /*Handle receiving a message that a previous offer has been accepted.
    They would have replied with another card as payment.*/
    private void doReceiveAcceptOffer(AcceptOffer trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }
        // Having received a AcceptOffer from another Player, add it to my hand of cards
        cards.add(trade.tradeCard);

        // check if the marker boolean flag is true and the channel does not contain the player
        // who initiated the trade. If the condition is satisfied add the player who initiated
        // the trade and the card being traded to the snapshot
        if(firstMarker & !channel.contains(trade.sourcePlayer)) {
            SnapshotAddition(trade.tradeCard);
        }

        System.out.println("PITplayer" + myPlayerNumber + " received: " + trade.tradeCard + " as payment from player: " + trade.sourcePlayer);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));
        // Make another offer to a random player
        doTenderOffer();
    }

    // Handle receiving a reject message regarding a prior offer I made
    private void doReceiveRejectOffer(RejectOffer trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }
        // Because the offer was rejected, and returned, add it back into my cards
        cards.add(trade.tradeCard);

        // check if the marker boolean flag is true and the channel does not contain the player
        // who initiated the trade. If the condition is satisfied add the player who initiated
        // the trade and the card being traded to the snapshot
        if(firstMarker & !channel.contains(trade.sourcePlayer)) {
            SnapshotAddition(trade.tradeCard);
        }

        System.out.println("PITplayer" + myPlayerNumber + " received rejected offer of: " + trade.tradeCard + " from player: " + trade.sourcePlayer);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));
        // Make another offer to a random player
        doTenderOffer();
    }

    // Make an offer to a random player
    private void doTenderOffer() throws Exception {
        // if hit maxTrades limit, then stop sending trades
        if (maxTrades(maxTrades)) {
            return;
        }
        /* If numPlayers == 0, while we have received a TenderOffer, we have not
         * received our NewHand yet, so we don't know how many players there
         * are.  Therefore, don't send out a TenderOffer at this time.
         */
        if (numPlayers == 0) {
            return;
        }
        // Create a new offer from my set of cards, and send to another player
        TenderOffer newTrade = new TenderOffer();
        newTrade.tradeCard = (String) cards.remove(0);
        newTrade.sourcePlayer = myPlayerNumber;

        // Find a random player to trade to (not including myself)
        int sendTo = myPlayerNumber;
        while (sendTo == myPlayerNumber) {
            sendTo = Math.round((float) Math.random() * (numPlayers - 1));
        }

        //Send the card to the other player
        System.out.println("PITplayer" + myPlayerNumber + " offered: " + newTrade.tradeCard + " to player: " + sendTo);
        String sendToJNDI = "openejb:Resource/PITplayer" + sendTo;
        sendToQueue(sendToJNDI, newTrade);

    }

    // Create a string of hand size and all cards
    private String toString(ArrayList hand) {

        StringBuilder cardsString = new StringBuilder("size: " + hand.size() + " ");
        for (Object o : hand) {
            cardsString.append(o).append(" ");
        }
        return cardsString.toString();
    }

    // Create a printable version of the "state".
    private String toString(HashMap<String, Integer> state) {
        StringBuilder stateString = new StringBuilder();
        for (Map.Entry<String, Integer> stringIntegerEntry : state.entrySet()) {
            String commodity = (String) ((Map.Entry) stringIntegerEntry).getKey();
            int number = (Integer) ((Map.Entry) stringIntegerEntry).getValue();
            stateString.append("{").append(commodity).append(":").append(number).append("} ");
        }
        return stateString.toString();
    }

    // Send an object to a Queue, given its JNDI name
    private void sendToQueue(String queueJNDI, Serializable message) throws Exception {
        // Gather necessary JMS resources
        Context ctxt = new InitialContext();
        Connection con = ((ConnectionFactory) ctxt.lookup("openejb:Resource/myConnectionFactory")).createConnection();
        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
        Queue q = (Queue) ctxt.lookup(queueJNDI);
        MessageProducer writer = session.createProducer(q);
        ObjectMessage msg = session.createObjectMessage(message);
        // Send the object to the Queue
        writer.send(msg);
        session.close();
        con.close();
        ctxt.close();
    }

    // Stop trading when the max number of Trades is reached
    private boolean maxTrades(int max) {
        if ((numTrades % 100) == 0) {
            System.out.println("PITplayer" + myPlayerNumber + " numTrades: " + numTrades);
        }
        return numTrades++ >= max;
    }
}